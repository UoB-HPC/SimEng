#include <algorithm>
#include <limits>

#include "RISCVRegressionTest.hh"

namespace {

using Exception = RISCVRegressionTest;

/** RISCV opcodes. Each opcode represents a unique RISCV operation. */
namespace Opcode {
#define GET_INSTRINFO_ENUM
#include "RISCVGenInstrInfo.inc"
}  // namespace Opcode

// Test that an invalid capstone instruction id raises an encoding unallocated
// exception
TEST_P(Exception, encoding_unallocated) {
  // Initialise heap with an unallocated encoding
  initialHeapData_.resize(4);
  uint32_t* heap = reinterpret_cast<uint32_t*>(initialHeapData_.data());
  heap[0] = 0xDEDEDEDE;
  RUN_RISCV(R"(
    # Get heap address
    li a0, 0
    li a7, 214
    ecall
    mv t0, a0

    jalr a0, t0, 0
  )");
  const char err[] =
      "\n[SimEng:ExceptionHandler] Encountered encoding unallocated exception";
  EXPECT_EQ(stdout_.substr(0, strlen(err)), err);
}

// Test that a instruction with no implemented execution logic raises a
// not-yet-implemented exception
TEST_P(Exception, not_yet_implemented) {
  // RISCV capstone has no undefined instruction opcode like aarch64, use a
  // currently unsupported instruction instead
  RUN_RISCV(R"(
    ebreak
  )");
  const char err[] =
      "\n[SimEng:ExceptionHandler] Encountered execution not-yet-implemented "
      "exception";
  EXPECT_EQ(stdout_.substr(0, strlen(err)), err);
}

// Test for InstructionException::AliasNotYetImplemented omitted. Obtaining an
// instruction encoding that will consistently trigger an AliasNotYetImplemented
// exception is not feasible due to the continual updates to our alias reversion
// support and the difficulty of generating the bytes for an instruction alias
// not yet supported.

// Test for InstructionException::MisalignedPC omitted. As defined by the ISA,
// RISCV implemented branch instructions use branch offsets that are restricted
// to be multiples of 2. Therefore, it is currently not possible to trigger a
// MisalignedPC exception.

// Test that trying to load data from an address outside the bounds of the
// process image raises a data abort exception
TEST_P(Exception, data_abort) {
  RUN_RISCV(R"(
    li a0, 10000
    mul a0, a0, a0
    ld t0, 0(a0)
  )");
  const char err[] =
      "\n[SimEng:ExceptionHandler] Encountered data abort exception";
  EXPECT_EQ(stdout_.substr(0, strlen(err)), err);
}

// Test that an unsupported SVC call raises an exception
TEST_P(Exception, unsupported_svc) {
  RUN_RISCV(R"(
    li a7, 3
    ecall
  )");

  // EQ comparison on the full exception output to ensure the correct system
  // call ID of 3 is printed
  int ecallOpcodeId = Opcode::RISCV_ECALL;
  std::string err =
      std::string(
          "\n[SimEng:ExceptionHandler] Encountered supervisor call "
          "exception\n[SimEng:ExceptionHandler]  Generated by "
          "instruction: \n[SimEng:ExceptionHandler]    0x0000000000000004: 73 "
          "00 00 00     ecall \n[SimEng:ExceptionHandler]      opcode ID: ") +
      std::to_string(ecallOpcodeId) +
      std::string("\n\n[SimEng:ExceptionHandler] Unrecognised syscall: 3");
  EXPECT_EQ(stdout_.substr(0, err.size()), err.c_str());
}

// TODO: Write test for InstructionException::HypervisorCall once it has a
// trigger case
// TODO: Write test for InstructionException::SecureMonitorCall once it has a
// trigger case

// Test that trying to process an instruction with no supporting issue port
// raises a no available port exception
TEST_P(Exception, no_available_port) {
  RUN_RISCV(R"(
    fld ft0, 0(a0)
    fld ft1, 8(a0)
    
    fadd.d ft4, ft0, ft1
  )");
  std::string err;
  // Exception raised on outoforder core archetype only
  if (std::get<0>(GetParam()) == OUTOFORDER) {
    err =
        "\n[SimEng:ExceptionHandler] Encountered unsupported execution "
        "port exception";
  } else {
    // Placeholder string for non-outoforder core to be replaced when
    // appropriate. Ensures changes to this test case won't be forgotten if
    // updates to other core archetypes are carried out such that they can now
    // raise an InstructionException::NoAvailablePort exception
    err =
        "\n[SimEng:ExceptionHandler] Encountered encoding unallocated "
        "exception";
  }
  EXPECT_EQ(stdout_.substr(0, err.size()), err.c_str());
}

// TODO: Write test for InstructionException::IllegalInstruction
// TODO: Write test for an successful InstructionException::PipelineFlush
// TODO: Write test for errored InstructionException::PipelineFlush once it has
// a trigger case

INSTANTIATE_TEST_SUITE_P(
    RISCV, Exception,
    ::testing::Values(
        std::make_tuple(EMULATION, "{}"), std::make_tuple(INORDER, "{}"),
        std::make_tuple(
            OUTOFORDER,
            "{Ports: {'0': {Portname: 0, Instruction-Group-Support: [INT, "
            "LOAD, STORE, BRANCH]}}}")),
    paramToString);

}  // namespace
