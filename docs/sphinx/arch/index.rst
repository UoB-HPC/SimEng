Overview
========

SimEng architecture definitions are responsible for describing the features and behaviour of specific Instruction Set Architectures (ISAs) in a standardised way, allowing SimEng to model processors that use these ISAs while itself remaining ISA agnostic.

To achieve this, SimEng defines a set of abstract architecture-related classes. Discrete implementations of these classes are provided for each of the ISAs SimEng supports by default, and must also be implemented for adding support for new or custom ISAs.

Architecture
------------

The main component of an ISA implementation is the ``Architecture`` class. During simulation initialisation, an reference to an instance of the modelled architecture is passed to the model, where it is queried to determine how various components should be initialised, and to allow components to perform further architecture-specific operations during simulation.

Architectures are expected to support querying the following information:

* The architectural register structure: the number of discrete types of registers, and the size and quantity of registers of each type.
* The initial state of the architectural registers and process memory at the time the simulation begins.

Pre-Decoding
************

The primary role of the ``Architecture`` class is to enable the conversion of arbitrary bytes of instruction memory into ``Instruction`` objects capable of performing operations. This process is referred to as *pre-decoding*, as it is responsible for grouping bytes into ":ref:`macro ops <macroops>`" representing individual machine-code instructions, which in real hardware would be decoded later into one or more instructions ("micro-ops"). In SimEng, all the decoding is expected to be performed up-front: the generated macro-op is simply a vector of micro-ops.

Exception Handling
******************

Architecture implementations must be capable of generating an :ref:`exceptionhandler` when presented with an instruction that has encountered an exception. The architecture will be presented with references to the current architectural register state and an interface to access process memory to facilitate this.


Instructions
------------

As different ISAs typically define a unique set of instructions, it is expected that each architecture implementation will also supply a custom :ref:`Instruction <instructions>` implementation. Instances of these instructions will be created during the pre-decode process performed by the main ``Architecture`` instance, and will be responsible for modelling the correct behaviour of that individual instruction.


.. _exceptionhandler:

Exception Handler
-----------------

For handling exceptions, SimEng provides an abstract ``ExceptionHandler`` class. Instances of ``ExceptionHandler`` should be generated by an ``Architecture`` instance upon request, by supplying the exception-generating instruction, a reference to the architectural register state, and a memory interface. As the details of exception handling vary between architecture, each supported architecture is expected to supply its own custom ``ExceptionHandler`` implementation.

Ticking
*******

Exception handlers provide a ``tick`` function, which may be called to process the exception it represents. Upon completing each tick, the exception handler will state whether or not further ticks are required---for example, to wait for a memory request to complete. If the exception requires further processing, the model will continue to tick it each cycle until completed.

Results
*******

When the exception has been fully processed, the results may be retrieved from the handler to retrieve the following information:

* Whether the exception was fatal
* The address that execution should resume from
* Any modifications to registers or process memory

If the exception is fatal, the core model will halt and the simulation will gracefully terminate. If not fatal, the supplied process state modifications will be applied and process execution will resume from the specified instruction address.
