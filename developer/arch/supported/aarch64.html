

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>AArch64 &mdash; SimEng  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="RISCV" href="riscv.html" />
    <link rel="prev" title="Abstract Structure" href="../abstract.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> SimEng
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Developer Documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developerInfo.html">Developer information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../concepts/index.html">Simulation Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../components/index.html">Simulation Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../models/index.html">Models</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Architectures</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../abstract.html">Abstract Structure</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">AArch64</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#decoding">Decoding</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#instruction-groups-opcodes">Instruction Groups/Opcodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#instruction-splitting">Instruction Splitting</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#adding-instructions">Adding instructions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#adding-execution-behaviour">Adding execution behaviour</a></li>
<li class="toctree-l4"><a class="reference internal" href="#helper-functions">Helper Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#zero-registers">Zero registers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#loads-and-stores">Loads and stores</a></li>
<li class="toctree-l4"><a class="reference internal" href="#instruction-aliases">Instruction aliases</a></li>
<li class="toctree-l4"><a class="reference internal" href="#common-instruction-execution-behaviour-issues">Common Instruction Execution behaviour issues</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#system-registers">System registers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#system-counter-timers">System Counter Timers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="riscv.html">RISCV</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../test/index.html">Testing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/building_simeng.html">Building SimEng</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/running_simeng.html">Running SimEng</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/configuring_simeng.html">Configuring SimEng</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/creating_binaries.html">Creating Binaries</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">SST Integration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../sst/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sst/building_simeng_with_sst.html">Building SimEng with SST</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sst/understanding_sst.html">Understanding SST</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sst/running_simeng_with_sst.html">Running SimEng with SST</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SimEng</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Architectures</a> &raquo;</li>
        
      <li>AArch64</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../../_sources/developer/arch/supported/aarch64.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="aarch64">
<h1><a class="toc-backref" href="#id1">AArch64</a><a class="headerlink" href="#aarch64" title="Permalink to this heading">¶</a></h1>
<p>SimEng provides an implementation of the 64-bit AArch64 architecture, specifically the Armv9.2-a ISA. This implementation provides support for decoding and executing a range of common instructions, sufficient to run a number of simple benchmarks. It is also capable of handling supervisor call (syscall) exceptions via basic system call emulation, allowing the execution of programs that have been statically compiled with the standard library.</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#aarch64" id="id1">AArch64</a></p>
<ul>
<li><p><a class="reference internal" href="#decoding" id="id2">Decoding</a></p>
<ul>
<li><p><a class="reference internal" href="#instruction-groups-opcodes" id="id3">Instruction Groups/Opcodes</a></p>
<ul>
<li><p><a class="reference internal" href="#implementation" id="id4">Implementation</a></p></li>
<li><p><a class="reference internal" href="#additional-information" id="id5">Additional information</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#instruction-splitting" id="id6">Instruction Splitting</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#adding-instructions" id="id7">Adding instructions</a></p>
<ul>
<li><p><a class="reference internal" href="#adding-execution-behaviour" id="id8">Adding execution behaviour</a></p>
<ul>
<li><p><a class="reference internal" href="#scalable-vector-extension" id="id9">Scalable Vector Extension</a></p></li>
<li><p><a class="reference internal" href="#scalable-matrix-extension" id="id10">Scalable Matrix Extension</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#helper-functions" id="id11">Helper Functions</a></p>
<ul>
<li><p><a class="reference internal" href="#cstool" id="id12">cstool</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#zero-registers" id="id13">Zero registers</a></p></li>
<li><p><a class="reference internal" href="#loads-and-stores" id="id14">Loads and stores</a></p></li>
<li><p><a class="reference internal" href="#instruction-aliases" id="id15">Instruction aliases</a></p></li>
<li><p><a class="reference internal" href="#common-instruction-execution-behaviour-issues" id="id16">Common Instruction Execution behaviour issues</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#system-registers" id="id17">System registers</a></p></li>
<li><p><a class="reference internal" href="#system-counter-timers" id="id18">System Counter Timers</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="decoding">
<h2><a class="toc-backref" href="#id2">Decoding</a><a class="headerlink" href="#decoding" title="Permalink to this heading">¶</a></h2>
<p>Instruction decoding is performed using the <a class="reference external" href="https://github.com/aquynh/capstone/">Capstone</a> disassembly framework. The disassembly generated by Capstone is used to determine the properties, operands, and execution behaviour of the corresponding instruction.</p>
<p>The logic held in <code class="docutils literal notranslate"><span class="pre">src/lib/arch/aarch64/Instruction_decode.cc</span></code> is primarily associated with converting the provided Capstone instruction metadata into the appropriate SimEng <code class="docutils literal notranslate"><span class="pre">instruction</span></code> format. Additionally, an instruction’s type identifiers are set here through operand usage and opcode values. For the AArch64 architecture model, the following identifiers are defined in <code class="docutils literal notranslate"><span class="pre">src/include/simeng/arch/aarch64/Instruction.hh</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">isScalarData</span></code>, operates on scalar values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isVectorData</span></code>, operates on vector values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isSVEData</span></code>, uses Z registers as source and/or destination operands.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isSMEData</span></code>, uses ZA tiles as source and/or destination operands.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isShift</span></code>, has a shift operand.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isLogical</span></code>, is a logical operation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isCompare</span></code>, is a compare operation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isConvert</span></code>, is a convert operation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isMultiply</span></code>, is a multiply operation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isDivideOrSqrt</span></code>, is a divide or square root operation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isPredicate</span></code>, writes to a predicate register.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isLoad</span></code>, is a load operation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isStoreAddress</span></code>, is a store address generation operation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isStoreData</span></code>, is a store data operation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isBranch</span></code>, is a branch operation.</p></li>
</ul>
<div class="section" id="instruction-groups-opcodes">
<span id="aarch64-instruction-groups"></span><h3><a class="toc-backref" href="#id3">Instruction Groups/Opcodes</a><a class="headerlink" href="#instruction-groups-opcodes" title="Permalink to this heading">¶</a></h3>
<p>Through a combination of the above identifiers, an instruction can be allocated an <a class="reference internal" href="../../concepts/instructions.html#instruction-group"><span class="std std-ref">instruction group</span></a>. The instruction groups available to the AArch64 ISA are detailed below:</p>
<img alt="AArch64 instruction groups" src="../../../_images/instruction_groups_AArch64.png" />
<p>The above diagram describes the instruction groups currently implemented for the AArch64 ISA. Each level of the diagram represents a different scope of instructions supported, the primary/top-level encapsulates the most instructions whilst the tertiary/bottom-level the least. The naming convention of the AArch64 instruction groups combines each of the levels within the above diagram through <code class="docutils literal notranslate"><span class="pre">_</span></code> characters, the top level is used first and connected to the required lower levels following the relationships shown. For example, to express an instruction group containing integer logical operations without any shift operands, the group <code class="docutils literal notranslate"><span class="pre">INT_SIMPLE_LOGICAL_NOSHIFT</span></code> would be used. Another example for all operations (excluding loads and stores) that operate on vector values would simply be <code class="docutils literal notranslate"><span class="pre">VECTOR</span></code>. The groups/subgroups chosen in the above diagram are derived from common separations in execution unit support and execution latencies of studied HPC processors.</p>
<p>This hierarchy-based naming convention has been chosen to provide the user with greater control over the number of instructions grouped under one name, whilst also remaining intuitive. A variety of combinations/instruction scopes can be defined through this method and only uses a small set of easily interpreted operation descriptions.</p>
<p>If the supplied instruction groups don’t provide a small enough scope, a numerical Capstone opcode can be used instead (found in <code class="docutils literal notranslate"><span class="pre">SimEng/build/_deps/capstone-lib-src/arch/AArch64/AArch64GenInstrInfo.inc</span></code>).</p>
<div class="section" id="implementation">
<h4><a class="toc-backref" href="#id4">Implementation</a><a class="headerlink" href="#implementation" title="Permalink to this heading">¶</a></h4>
<p>The available instruction groups can be found in <code class="docutils literal notranslate"><span class="pre">SimEng/src/include/simeng/arch/aarch64/InstructionGroups.hh</span></code> under the <code class="docutils literal notranslate"><span class="pre">InstructionGroups</span></code> namespace. The implementation of the relationship between groups, as described in the above diagram, can be found in the same file as an <code class="docutils literal notranslate"><span class="pre">unordered_map</span></code> named <code class="docutils literal notranslate"><span class="pre">groupInheritance</span></code>. The keys of <code class="docutils literal notranslate"><span class="pre">groupInheritance</span></code> represent the parent node of the relationship and the values, the children nodes. The relationships defined by one entry of the <code class="docutils literal notranslate"><span class="pre">groupInheritance</span></code> map only represents a single parent-child relationship, therefore, the reading of <code class="docutils literal notranslate"><span class="pre">groupInheritance</span></code> relationships are performed recursively. This decision was made to reduce the amount of code used in the instantiation of the <code class="docutils literal notranslate"><span class="pre">groupInheritance</span></code> object.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">getGroup()</span></code> function in <code class="docutils literal notranslate"><span class="pre">SimEng/src/lib/arch/aarch64/Instruction.cc</span></code> contains the logic for converting an instructions’ identifiers to an instruction group. The <code class="docutils literal notranslate"><span class="pre">InstructionGroups</span></code> namespace has been ordered such that each data type group (<code class="docutils literal notranslate"><span class="pre">INT</span></code>, <code class="docutils literal notranslate"><span class="pre">SCALAR</span></code>, etc) is followed by the set of possible operation type groups (<code class="docutils literal notranslate"><span class="pre">*_SIMPLE_ARTH</span></code>, <code class="docutils literal notranslate"><span class="pre">*_MUL</span></code>, etc). A combination of a base and a relative offset value is used to implement the conversion. The base value is defined as one of the data type groups, whilst the relative offset value represents an operation type group. For those groups that don’t conform to this relationship, e.g. <code class="docutils literal notranslate"><span class="pre">BRANCH</span></code> or <code class="docutils literal notranslate"><span class="pre">PREDICATE</span></code>, a simple conditional clause is defined.</p>
</div>
<div class="section" id="additional-information">
<h4><a class="toc-backref" href="#id5">Additional information</a><a class="headerlink" href="#additional-information" title="Permalink to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">FP</span></code> primary identifier is a placeholder to denote both the <code class="docutils literal notranslate"><span class="pre">SCALAR</span></code> and <code class="docutils literal notranslate"><span class="pre">VECTOR</span></code> primary identifiers such that, amongst the other combinations, <code class="docutils literal notranslate"><span class="pre">FP_SIMPLE_ARTH</span></code> expands to be <code class="docutils literal notranslate"><span class="pre">SCALAR_SIMPLE_ARTH</span></code> and <code class="docutils literal notranslate"><span class="pre">VECTOR_SIMPLE_ARTH</span></code>. In some cases it was unnecessary and inconvenient to separate <code class="docutils literal notranslate"><span class="pre">SCALAR</span></code> and <code class="docutils literal notranslate"><span class="pre">VECTOR</span></code> operations within configuration options, therefore, this instruction group option was provided to solve the issue.</p>
<p>When setting the latencies for instruction groups, within the <a class="reference internal" href="../../../user/configuring_simeng.html#config-latencies"><span class="std std-ref">Latencies</span></a> section of the configurable options, the inheritance between instruction groups is taken into account (e.g. the <code class="docutils literal notranslate"><span class="pre">VECTOR</span></code> group latency assignment would be inherited by all <code class="docutils literal notranslate"><span class="pre">VECTOR_*</span></code> groups). If multiple entries could assign a latency value to an instruction group, the option with the least levels of inheritance to the instruction group takes priority. As an example, take the groups <code class="docutils literal notranslate"><span class="pre">INT_SIMPLE</span></code> and <code class="docutils literal notranslate"><span class="pre">INT_SIMPLE_ARTH</span></code>. <code class="docutils literal notranslate"><span class="pre">INT_SIMPLE_ARTH_NOSHIFT</span></code> inherits from both of these groups but because <code class="docutils literal notranslate"><span class="pre">INT_SIMPLE_ARTH</span></code> has one less level of inheritance to traverse, <code class="docutils literal notranslate"><span class="pre">INT_SIMPLE_ARTH_NOSHIFT</span></code> inherits <code class="docutils literal notranslate"><span class="pre">INT_SIMPLE_ARTH</span></code> latency values.</p>
</div>
</div>
<div class="section" id="instruction-splitting">
<h3><a class="toc-backref" href="#id6">Instruction Splitting</a><a class="headerlink" href="#instruction-splitting" title="Permalink to this heading">¶</a></h3>
<p>Instruction splitting is performed within the <code class="docutils literal notranslate"><span class="pre">decode</span></code> function in <code class="docutils literal notranslate"><span class="pre">MicroDecoder.cc</span></code>. A macro-op is taken into the <code class="docutils literal notranslate"><span class="pre">decode</span></code> function and one or more micro-ops, taking the form of SimEng <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> objects, are returned. The following instruction splitting is supported:</p>
<ul class="simple">
<li><p>Load pair for X/W/S/D/Q registers.</p>
<ul>
<li><p>Post-index splits into two load operations and an add operation.</p></li>
<li><p>Pre-index splits into an add operation and two load operations.</p></li>
<li><p>Signed offset splits into two load operations.</p></li>
</ul>
</li>
<li><p>Load for X/W/B/H/S/D/Q registers.</p>
<ul>
<li><p>Post-index splits into a load operation and an add operation.</p></li>
<li><p>Pre-index splits into an add operation and a load operation.</p></li>
</ul>
</li>
<li><p>Store pair for X/W/S/D/Q registers.</p>
<ul>
<li><p>Post-index splits into two store address generation operations, two store data operations, and an add operation.</p></li>
<li><p>Pre-index splits into an add operation, two store address generation operations, and two store data operations.</p></li>
<li><p>Signed offset splits into two store address generation operations and two store data operations.</p></li>
</ul>
</li>
<li><p>Store for X/W/B/H/S/D/Q registers.</p>
<ul>
<li><p>Post-index splits into a store address generation operation, a store data operation, and an add operation.</p></li>
<li><p>Pre-index splits into an add operation, a store address generation operation, and a store data operation.</p></li>
<li><p>Signed offset splits into a store address generation operation and a store data operation.</p></li>
</ul>
</li>
</ul>
<p>Each micro-operation opcode is set to one of the options available in the <code class="docutils literal notranslate"><span class="pre">MicroOpcode</span></code> namespace. This value is later used to determine the <code class="docutils literal notranslate"><span class="pre">Instruction_address.cc</span></code> and <code class="docutils literal notranslate"><span class="pre">Instruction_execute.cc</span></code> logic of the micro-operation.</p>
</div>
</div>
<div class="section" id="adding-instructions">
<h2><a class="toc-backref" href="#id7">Adding instructions</a><a class="headerlink" href="#adding-instructions" title="Permalink to this heading">¶</a></h2>
<p id="aarch64-adding-instructions">Due to the vast number of AArch64 instruction variants, instructions are only added to this architecture as encountered in programs using them; as a result, to run a new program it will likely be necessary to add support for a number of instructions.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When adding support for new instructions, it’s recommended to run SimEng in emulation mode for both speed, and for an execution flow that’s easier to follow.</p>
</div>
<p>When you first run the new program through SimEng, execution will occur as normal until an unsupported instruction reaches the retirement point. This will then generate an not-yet-implemented exception, which the architecture will catch and provide a useful output before terminating. An example of the expected output is below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Encountered</span> <span class="n">execution</span> <span class="ow">not</span><span class="o">-</span><span class="n">yet</span><span class="o">-</span><span class="n">implemented</span> <span class="n">exception</span>
  <span class="n">Generated</span> <span class="n">by</span> <span class="n">instruction</span><span class="p">:</span>
    <span class="mh">0x00000000004004a8</span><span class="p">:</span> <span class="n">f3</span> <span class="mi">0</span><span class="n">f</span> <span class="mi">1</span><span class="n">e</span> <span class="n">f8</span>     <span class="nb">str</span> <span class="n">x19</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">,</span> <span class="c1">#-0x20]!</span>
      <span class="n">opcode</span> <span class="n">ID</span><span class="p">:</span> <span class="mi">1920</span>
<span class="n">Halting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">fatal</span> <span class="n">exception</span>
</pre></div>
</div>
<p>This information includes the program address of the unrecognised instruction, the bytes of the encoded instruction, and the textual representation of the instruction. An “opcode ID” is also provided: this corresponds to a specific value in the <code class="docutils literal notranslate"><span class="pre">simeng::arch::aarch64::Opcode</span></code> namespace, imported from Capstone.</p>
<div class="section" id="adding-execution-behaviour">
<h3><a class="toc-backref" href="#id8">Adding execution behaviour</a><a class="headerlink" href="#adding-execution-behaviour" title="Permalink to this heading">¶</a></h3>
<p>The first step to add a new instruction (and the only, for many instructions) is to add a new entry into the execution behaviour table found in <code class="docutils literal notranslate"><span class="pre">src/lib/arch/aarch64/Instruction_execute.cc</span></code>. These entries are responsible for reading the input operands and generating one or more results that may be read by the model handling the instruction. The entry should be uniquely identified by the namespace entry corresponding to the opcode ID presented by SimEng when the unsupported instruction was encountered.</p>
<p>There are several useful variables that execution behaviours have access to:</p>
<p><code class="docutils literal notranslate"><span class="pre">sourceValues_</span></code></p>
<blockquote id="aarch64-adding-execution-behaviour-operands">
<div><p>This is a vector of <code class="docutils literal notranslate"><span class="pre">RegisterValue</span></code>, with each value corresponding to one of the input operands. For most instructions, <code class="docutils literal notranslate"><span class="pre">sourceValues_[0]</span></code> will be the <em>second</em> operand as written textually, as the first operand is typically the destination register. E.g., for the instruction <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">w0,</span> <span class="pre">w1,</span> <span class="pre">w2</span></code>, <code class="docutils literal notranslate"><span class="pre">sourceValues_[0]</span></code> will correspond to <code class="docutils literal notranslate"><span class="pre">w1</span></code> and <code class="docutils literal notranslate"><span class="pre">[1]</span></code> to <code class="docutils literal notranslate"><span class="pre">w2</span></code>.</p>
<p>Some instructions have “implicit” register reads: these are added to the <strong>start</strong> of the operand array. E.g., the instruction <code class="docutils literal notranslate"><span class="pre">b.ne</span> <span class="pre">#16</span></code> implicitly reads the “NZCV” flags. In this case, <code class="docutils literal notranslate"><span class="pre">sourceValues_[0]</span></code> will be the value of the flag register.</p>
<p>Some instructions have operands to which they both read and write, such as <code class="docutils literal notranslate"><span class="pre">fmla</span> <span class="pre">v0.d,</span> <span class="pre">v1.d,</span> <span class="pre">v2.d</span></code> both writing to <em>and</em> reading from <code class="docutils literal notranslate"><span class="pre">v0.d</span></code>; in this case, <code class="docutils literal notranslate"><span class="pre">sourceValues_[0]</span></code> is <code class="docutils literal notranslate"><span class="pre">v0.d</span></code>, and <code class="docutils literal notranslate"><span class="pre">[1]</span></code> and <code class="docutils literal notranslate"><span class="pre">[2]</span></code> are <code class="docutils literal notranslate"><span class="pre">v1.d</span></code> and <code class="docutils literal notranslate"><span class="pre">v2.d</span></code> respectively.</p>
<p>Instructions such as stores may not have any destination registers at all. In these cases, the <code class="docutils literal notranslate"><span class="pre">sourceValues_</span></code> indices match the positions as they appear: the first operand is <code class="docutils literal notranslate"><span class="pre">[0]</span></code>, the second <code class="docutils literal notranslate"><span class="pre">[1]</span></code>, and so on.</p>
</div></blockquote>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">results</span></code></dt><dd><p>This is the output vector, into which <code class="docutils literal notranslate"><span class="pre">RegisterValue</span></code> instances containing the results should be placed. Each entry in the vector corresponds to a destination register.</p>
<p>Some instructions have “implicit” destination registers: in these cases, the implicit destinations are added to the start of the results vector. For example, <code class="docutils literal notranslate"><span class="pre">subs</span> <span class="pre">w0,</span> <span class="pre">w1,</span> <span class="pre">#1</span></code> writes explicitly to <code class="docutils literal notranslate"><span class="pre">w0</span></code>, but also implicitly sets the “NZCV” comparison flags. In this case, <code class="docutils literal notranslate"><span class="pre">results[0]</span></code> is expected to be the updated NZCV flags, while <code class="docutils literal notranslate"><span class="pre">results[1]</span></code> is expected to be the new value of <code class="docutils literal notranslate"><span class="pre">w0</span></code>.</p>
<p>Memory instructions may have a “writeback” variant, where the register containing the address is updated by an offset during execution. In these cases, the address register is added as a destination <em>after</em> the other registers, corresponding with the textual representation of the registers. E.g., the instruction <code class="docutils literal notranslate"><span class="pre">ldr</span> <span class="pre">x1,</span> <span class="pre">[x2,</span> <span class="pre">#8]!</span></code> will expect the value of <code class="docutils literal notranslate"><span class="pre">x1</span></code> in <code class="docutils literal notranslate"><span class="pre">results[0]</span></code>, while the updated address <code class="docutils literal notranslate"><span class="pre">x2</span></code> should be placed in <code class="docutils literal notranslate"><span class="pre">results[1]</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">metadata</span></code></dt><dd><p>Each instruction stores a simplified form of the full disassembly metadata generated by Capstone. This is stored in the <code class="docutils literal notranslate"><span class="pre">metadata</span></code> member variable, and is of type <code class="docutils literal notranslate"><span class="pre">InstructionMetadata</span></code>. The metadata object contains an <code class="docutils literal notranslate"><span class="pre">metadata.operands</span></code> array with entries corresponding to the textual operands of the instruction. <strong>Note:</strong> Unlike the instruction’s <code class="docutils literal notranslate"><span class="pre">sourceValues_</span></code> member variable, <code class="docutils literal notranslate"><span class="pre">metadata.operands</span></code> entries correspond directly to their textual equivalent. For example, in the instruction <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">w0,</span> <span class="pre">w1,</span> <span class="pre">w2</span></code>, <code class="docutils literal notranslate"><span class="pre">metadata.operands[0]</span></code> will describe <code class="docutils literal notranslate"><span class="pre">w0</span></code>, <code class="docutils literal notranslate"><span class="pre">[1]</span></code> describes <code class="docutils literal notranslate"><span class="pre">w1</span></code>, and so on.</p>
<p>The primary use for this data is to retrieve immediate values. For example, with the instruction <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">w0,</span> <span class="pre">w1,</span> <span class="pre">#1</span></code>, <code class="docutils literal notranslate"><span class="pre">metadata.operands[2].imm</span></code> would contain the value <code class="docutils literal notranslate"><span class="pre">1</span></code>. Floating point immediates are similarly available, using <code class="docutils literal notranslate"><span class="pre">.fp</span></code> in place of <code class="docutils literal notranslate"><span class="pre">.imm</span></code>.</p>
<p>For memory operations, the <em>entire</em> memory address section is treated as a single <code class="docutils literal notranslate"><span class="pre">metadata.operands</span></code> entry, with information available under <code class="docutils literal notranslate"><span class="pre">metadata.operands[n].mem</span></code>. For example, for the instruction <code class="docutils literal notranslate"><span class="pre">ldr</span> <span class="pre">x0,</span> <span class="pre">[sp,</span> <span class="pre">#8]</span></code>, <code class="docutils literal notranslate"><span class="pre">metadata.operands[1].mem</span></code> contains information on the <code class="docutils literal notranslate"><span class="pre">[sp,</span> <span class="pre">#8]</span></code> block, with <code class="docutils literal notranslate"><span class="pre">metadata.operands[1].mem.disp</span></code> containing the specified offset of <code class="docutils literal notranslate"><span class="pre">8</span></code>.</p>
</dd>
</dl>
<div class="section" id="scalable-vector-extension">
<h4><a class="toc-backref" href="#id9">Scalable Vector Extension</a><a class="headerlink" href="#scalable-vector-extension" title="Permalink to this heading">¶</a></h4>
<p>SimEng supports the Arm SVE extension and thus the use of <code class="docutils literal notranslate"><span class="pre">Z</span></code> vector registers. <code class="docutils literal notranslate"><span class="pre">Z</span></code> registers are an extension of the Arm NEON <code class="docutils literal notranslate"><span class="pre">V</span></code> vector registers whereby the <code class="docutils literal notranslate"><span class="pre">V</span></code> register variant occupies the lower 16 bytes of the <code class="docutils literal notranslate"><span class="pre">Z</span></code> registers total 256 bytes. Under the Arm SVE extension, the implemented logic for writing to a <code class="docutils literal notranslate"><span class="pre">V</span></code> register is to zero-out the upper 240 bytes of the associated <code class="docutils literal notranslate"><span class="pre">Z</span></code> register (e.g. <code class="docutils literal notranslate"><span class="pre">z1</span></code> and <code class="docutils literal notranslate"><span class="pre">v1</span></code>) and treat its lower 16 bytes as the <code class="docutils literal notranslate"><span class="pre">V</span></code> register. SimEng will automatically apply this logic when the execution of an instruction contains a <code class="docutils literal notranslate"><span class="pre">V</span></code> register as a destination location.</p>
</div>
<div class="section" id="scalable-matrix-extension">
<h4><a class="toc-backref" href="#id10">Scalable Matrix Extension</a><a class="headerlink" href="#scalable-matrix-extension" title="Permalink to this heading">¶</a></h4>
<p>Also supported is the Arm SME extension and thus the use of <code class="docutils literal notranslate"><span class="pre">ZA</span></code> sub-tile registers. The implementation of the <code class="docutils literal notranslate"><span class="pre">ZA</span></code> register is to treat each horizontal row the same as a vector register. Therefore, if a source operand is a sub-tile of <code class="docutils literal notranslate"><span class="pre">ZA</span></code> and contains 16 rows, then there will be 16 corresponding entries in the <code class="docutils literal notranslate"><span class="pre">sourceValues_</span></code> vector. Likewise, if a destination operand is <code class="docutils literal notranslate"><span class="pre">ZA</span></code> or a sub-tile of <code class="docutils literal notranslate"><span class="pre">ZA</span></code> then the <code class="docutils literal notranslate"><span class="pre">results</span></code> vector will require the corresponding number of horizontal rows.</p>
<p>SME instructions can also operate on sub-tile slices; individual rows or columns within a sub-tile. Regardless of whether a whole sub-tile or a slice is used as a source operand, all rows associated with said tile will be added to the <code class="docutils literal notranslate"><span class="pre">sourceValues_</span></code> vector. There are two reasons for this. First, the index value pointing to the relevant slice cannot be evaluated before instruction execution, thus, all sub-tile rows need to be provided. Second, if the source slice is a vertical slice (or a column of the sub-tile) then an element from each row is needed to construct the correct output.</p>
<p>Furthermore, a similar situation is present when a sub-tile slice is a destination operand. The <code class="docutils literal notranslate"><span class="pre">results</span></code> vector will expect a <code class="docutils literal notranslate"><span class="pre">registerValue</span></code> entry for each row of the targeted sub-tile, again due to the same two reasons listed previously. But, when a sub-tile slice is a destination operand, <strong>all</strong> associated rows of the sub-tile will also be added to the <code class="docutils literal notranslate"><span class="pre">sourceValues_</span></code> vector. Again, this is down to two key, similar reasons. First, when a destination is a sub-tile slice, we only want to update that row or column. As the we are unable to calculate which slice will be our destination before execution has commenced, all possible slices must be added to the <code class="docutils literal notranslate"><span class="pre">results</span></code> vector. If we were to not provide a <code class="docutils literal notranslate"><span class="pre">RegisterValue</span></code> to each entry of the <code class="docutils literal notranslate"><span class="pre">results</span></code> vector, the default value is 0. Therefore, in order to not zero-out the other slices within the sub-tile we will need access to their current values. Secondly, if the destination is a vertical slice (or sub-tile column) then only one element per row should be updated; the rest should remain unchanged.</p>
<p>Before implementing any further SME functionality we highly recommend familiarising yourself with the specification; found <a class="reference external" href="https://developer.arm.com/documentation/ddi0616/latest">here</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We strongly encourage adding regression tests for each implemented instruction at the same time as adding execution behaviour to ensure functional validity.</p>
</div>
</div>
</div>
<div class="section" id="helper-functions">
<h3><a class="toc-backref" href="#id11">Helper Functions</a><a class="headerlink" href="#helper-functions" title="Permalink to this heading">¶</a></h3>
<p>Found in <code class="docutils literal notranslate"><span class="pre">src/include/simeng/arch/aarch64/helpers/</span></code> are helper functions which abstract the logic away from <code class="docutils literal notranslate"><span class="pre">Instruction_execute.cc</span></code> into re-usable functions.
Their use reduces the amount of repeated code within <code class="docutils literal notranslate"><span class="pre">Instruction_execute.cc</span></code> and speeds up the process of adding new instructions.</p>
<p>The functions are grouped by instruction type (arithmetic, neon, sve, etc.) and are accompanied by a brief description detailing:</p>
<blockquote>
<div><ul class="simple">
<li><p>What instruction format they support.</p></li>
<li><p>The template type required.</p></li>
<li><p>What the function returns.</p></li>
</ul>
</div></blockquote>
<p>We recommend that when implementing a new instruction you first look through the already implemented helper functions to try and find one which you could use.
If none of the existing helper functions are of use, then we recommend implementing a new one for your instruction type. This will speed up adding support for other variants of this instruction in the future.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Load and Store instructions do not currently have any helper functions available.</p>
</div>
<div class="section" id="cstool">
<h4><a class="toc-backref" href="#id12">cstool</a><a class="headerlink" href="#cstool" title="Permalink to this heading">¶</a></h4>
<p>Capstone provides a <code class="docutils literal notranslate"><span class="pre">cstool</span></code> utility, which provides a visual representation of the <code class="docutils literal notranslate"><span class="pre">metadata</span></code> information available for any given instruction. For example, feeding it the bytes for the <code class="docutils literal notranslate"><span class="pre">str</span></code> instruction displayed above results in the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cstool -d arm64 f30f1ef8
 0  f3 0f 1e f8  str    x19, [sp, #-0x20]!
        op_count: 2
                operands[0].type: REG = x19
                operands[0].access: READ
                operands[1].type: MEM
                        operands[1].mem.base: REG = sp
                        operands[1].mem.disp: 0xffffffe0
                operands[1].access: READ | WRITE
        Write-back: True
        Registers read: x19 sp
        Registers modified: sp
</pre></div>
</div>
</div>
</div>
<div class="section" id="zero-registers">
<h3><a class="toc-backref" href="#id13">Zero registers</a><a class="headerlink" href="#zero-registers" title="Permalink to this heading">¶</a></h3>
<p>AArch64 provides two zero registers, <code class="docutils literal notranslate"><span class="pre">WZR</span></code> and <code class="docutils literal notranslate"><span class="pre">XZR</span></code>, which are always read as 0. This implementation mirrors that behaviour, and will automatically populate the relevant <code class="docutils literal notranslate"><span class="pre">sourceValues_</span></code> entry with a 0-value <code class="docutils literal notranslate"><span class="pre">RegisterValue</span></code>.</p>
<p>For instructions that are capable of generating multiple results (typically flag-setting instructions), they can claim to write to one of the zero registers: in these cases, the result is discarded. This implementation supports this behaviour, and reduces the number of available <code class="docutils literal notranslate"><span class="pre">results</span></code> entries accordingly.</p>
</div>
<div class="section" id="loads-and-stores">
<h3><a class="toc-backref" href="#id14">Loads and stores</a><a class="headerlink" href="#loads-and-stores" title="Permalink to this heading">¶</a></h3>
<p>In addition to an execution behaviour, memory instructions also require a new entry in the address generation behaviour table found in <code class="docutils literal notranslate"><span class="pre">src/lib/arch/aarch64/Instruction_address.cc</span></code>. These entries are responsible for describing the method used to generate the addresses that these instructions will read from or write to.</p>
<p>Address generation is expected to generate one or more instances of <code class="docutils literal notranslate"><span class="pre">MemoryAccessTarget</span></code>, containing an address and the number of bytes to access. The same variables described above (<code class="docutils literal notranslate"><span class="pre">sourceValues_</span></code>, <code class="docutils literal notranslate"><span class="pre">metadata</span></code>) are available to use to generate these addresses.</p>
<p>Once the addresses have been generated, they should be supplied in a vector to the <code class="docutils literal notranslate"><span class="pre">setMemoryAddresses</span></code> helper function.</p>
<p>For loads, data can be read from the <code class="docutils literal notranslate"><span class="pre">memoryData</span></code> vector in <code class="docutils literal notranslate"><span class="pre">Instruction_execute.cc</span></code>, with each index holding a <code class="docutils literal notranslate"><span class="pre">RegisterValue</span></code> for a corresponding <code class="docutils literal notranslate"><span class="pre">MemoryAccessTarget</span></code>. For stores, a <code class="docutils literal notranslate"><span class="pre">RegisterValue</span></code> must be placed in each index of the <code class="docutils literal notranslate"><span class="pre">memoryData</span></code> vector, again one per <code class="docutils literal notranslate"><span class="pre">MemoryAccessTarget</span></code> generated.</p>
<p>To best match modelled hardware, contiguous Load and Store instructions use one <code class="docutils literal notranslate"><span class="pre">MemoryAccessTarget</span></code> per destination/source register. For NEON instructions this should always be the case, including interleaved multi-structure loads / stores.</p>
<p>Concerning SVE &amp; SME loads and stores, an effort should be made to merge contiguous active elements into as few <code class="docutils literal notranslate"><span class="pre">MemoryAccessTarget</span></code>’s as possible by evaluating the predicate information (if applicable). Helper functions <code class="docutils literal notranslate"><span class="pre">sve_merge_store_data</span></code> and <code class="docutils literal notranslate"><span class="pre">generatePredicatedContiguousAddressBlocks</span></code> can be used to support this.</p>
</div>
<div class="section" id="instruction-aliases">
<h3><a class="toc-backref" href="#id15">Instruction aliases</a><a class="headerlink" href="#instruction-aliases" title="Permalink to this heading">¶</a></h3>
<p>As Capstone is primarily a disassembler, it will attempt to generate the correct aliases for instructions: for example, the <code class="docutils literal notranslate"><span class="pre">cmp</span> <span class="pre">w0,</span> <span class="pre">#0</span></code> instruction is an alias for <code class="docutils literal notranslate"><span class="pre">subs</span> <span class="pre">wzr,</span> <span class="pre">w0,</span> <span class="pre">#0</span></code>. As it’s the underlying instruction that is of use (in this case, the <code class="docutils literal notranslate"><span class="pre">subs</span></code> instruction), this implementation includes a de-aliasing component that reverses this conversion. The logic for this may be found in <code class="docutils literal notranslate"><span class="pre">src/lib/arch/aarch64/InstructionMetadata</span></code>.</p>
<p>If a known but unsupported alias is encountered, it will generate an invalid instruction error, and the output will identify the instruction as unknown in place of the usual textual representation. It is recommended to reference a disassembled version of the program to identify what the instruction at this address should be correctly disassembled to, and implement the necessary dealiasing logic accordingly.</p>
</div>
<div class="section" id="common-instruction-execution-behaviour-issues">
<h3><a class="toc-backref" href="#id16">Common Instruction Execution behaviour issues</a><a class="headerlink" href="#common-instruction-execution-behaviour-issues" title="Permalink to this heading">¶</a></h3>
<p>Often newly added instructions will be implemented correctly but their tests will fail or they will exhibit incorrect execution behaviour. This is especially common with SVE instructions. The most common reason for this is Capstone assigning incorrect operand access rights to each operand. To fix this, a case should be added to the switch statement in the <code class="docutils literal notranslate"><span class="pre">InstructionMetadata.cc</span></code> constructor function. An example statement can be seen below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">Opcode</span><span class="p">::</span><span class="n">AArch64_LD1Onev16b_POST</span><span class="p">:</span> <span class="o">//</span> <span class="n">ld1</span> <span class="p">{</span><span class="n">vt</span><span class="mf">.16</span><span class="n">b</span><span class="p">},</span> <span class="p">[</span><span class="n">xn</span><span class="p">],</span> <span class="c1">#imm</span>
  <span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">access</span> <span class="o">=</span> <span class="n">CS_AC_WRITE</span><span class="p">;</span>               <span class="o">//</span> <span class="n">vt</span><span class="mf">.16</span><span class="n">b</span> <span class="n">access</span>
  <span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">access</span> <span class="o">=</span> <span class="n">CS_AC_READ</span> <span class="o">|</span> <span class="n">CS_AC_WRITE</span><span class="p">;</span>  <span class="o">//</span> <span class="n">xn</span> <span class="n">access</span>
  <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<p>If after adding a case to the metadata switch statement the execution behaviour of your instruction is still incorrect, please submit an issue describing the instruction in question along with the error you are experiencing.</p>
</div>
</div>
<div class="section" id="system-registers">
<h2><a class="toc-backref" href="#id17">System registers</a><a class="headerlink" href="#system-registers" title="Permalink to this heading">¶</a></h2>
<p>AArch64 defines many system registers, which are treated the same as any other explicit source or destination register within SimEng.</p>
<p>Similar to instructions, system register support is added when they are encountered in run programs. To add support for a previously unseen system register, it must be added to the <code class="docutils literal notranslate"><span class="pre">systemRegisterMap_</span></code> map in the associated ISA <code class="docutils literal notranslate"><span class="pre">Architecture.cc</span></code> file.</p>
</div>
<div class="section" id="system-counter-timers">
<h2><a class="toc-backref" href="#id18">System Counter Timers</a><a class="headerlink" href="#system-counter-timers" title="Permalink to this heading">¶</a></h2>
<p>Present in AArch64 are two main system timers; the Counter-timer Virtual Count Register <a class="reference external" href="https://developer.arm.com/documentation/ddi0601/2022-09/AArch64-Registers/CNTVCT-EL0--Counter-timer-Virtual-Count-register?lang=en">CNTVCT</a>, and the Performance Monitors Cycle Count Register <a class="reference external" href="https://developer.arm.com/documentation/ddi0601/2022-09/AArch64-Registers/PMCCNTR-EL0--Performance-Monitors-Cycle-Count-Register?lang=en">PMCCNTR</a>. The CNTVCT system register holds a virtual cycle count, and is incremented at a defined frequency (see <a class="reference internal" href="../../../user/configuring_simeng.html#core"><span class="std std-ref">Configuring SimEng</span></a>). The PMCCNTR system register holds the real processor cycle count. Both are supported in SimEng and are accessible to the programmer through the appropriate <code class="docutils literal notranslate"><span class="pre">mrs</span></code> instructions. The logic which updates these registers can be found at <code class="docutils literal notranslate"><span class="pre">src/lib/arch/aarch64/Architecture.cc:updateSystemTimerRegisters</span></code> and is invoked inside each of the core model’s <code class="docutils literal notranslate"><span class="pre">tick()</span></code> function.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="riscv.html" class="btn btn-neutral float-right" title="RISCV" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="../abstract.html" class="btn btn-neutral float-left" title="Abstract Structure" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2024, SimEng developers.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>