#include "A64Architecture.hh"

#include <algorithm>
#include <cassert>
#include <iomanip>
#include <iostream>

#include "A64InstructionMetadata.hh"

namespace simeng {

std::unordered_map<uint32_t, A64Instruction> A64Architecture::decodeCache;
std::forward_list<A64InstructionMetadata> A64Architecture::metadataCache;

A64Architecture::A64Architecture(kernel::Linux& kernel) : linux_(kernel) {
  if (cs_open(CS_ARCH_ARM64, CS_MODE_ARM, &capstoneHandle) != CS_ERR_OK) {
    std::cerr << "Could not create capstone handle" << std::endl;
    exit(1);
  }

  cs_option(capstoneHandle, CS_OPT_DETAIL, CS_OPT_ON);
}
A64Architecture::~A64Architecture() { cs_close(&capstoneHandle); }

uint8_t A64Architecture::predecode(const void* ptr, uint8_t bytesAvailable,
                                   uint64_t instructionAddress,
                                   BranchPrediction prediction,
                                   MacroOp& output) const {
  assert(bytesAvailable >= 4 && "Fewer than 4 bytes supplied to A64 decoder");

  // Dereference the instruction pointer to obtain the instruction word
  const uint32_t insn = *static_cast<const uint32_t*>(ptr);
  const uint8_t* encoding = reinterpret_cast<const uint8_t*>(ptr);

  if (!decodeCache.count(insn)) {
    // Generate a fresh decoding, and add to cache
    cs_insn rawInsn;
    cs_detail rawDetail;
    rawInsn.detail = &rawDetail;

    size_t size = 4;
    uint64_t address = 0;

    bool success =
        cs_disasm_iter(capstoneHandle, &encoding, &size, &address, &rawInsn);

    auto metadata = success ? A64InstructionMetadata(rawInsn)
                            : A64InstructionMetadata(encoding);

    // Cache the metadata
    metadataCache.emplace_front(metadata);
    // Create and cache an instruction using the metadata
    decodeCache.insert({insn, metadataCache.front()});
  }

  // Retrieve the cached instruction
  std::shared_ptr<Instruction> uop =
      std::make_shared<A64Instruction>(decodeCache.find(insn)->second);

  uop->setInstructionAddress(instructionAddress);
  uop->setBranchPrediction(prediction);

  // Bundle uop into output macro-op and return
  output.resize(1);
  output[0] = uop;

  return 4;
}

ExceptionResult A64Architecture::handleException(
    const std::shared_ptr<Instruction>& instruction,
    const ArchitecturalRegisterFileSet& registerFileSet,
    const char* memory) const {
  A64Instruction& insn = *static_cast<A64Instruction*>(instruction.get());

  printException(insn);

  A64InstructionException exception = insn.getException();

  if (exception == A64InstructionException::SupervisorCall) {
    uint64_t nextInstructionAddress = insn.getInstructionAddress() + 4;
    // Retrieve syscall ID held in register x8
    auto syscallId =
        registerFileSet.get({A64RegisterType::GENERAL, 8}).get<uint64_t>();
    std::cout << "Syscall ID is " << syscallId << std::endl;

    ProcessStateChange stateChange;
    const Register x0 = {A64RegisterType::GENERAL, 0};
    const Register x1 = {A64RegisterType::GENERAL, 1};
    const Register x2 = {A64RegisterType::GENERAL, 2};
    const Register x3 = {A64RegisterType::GENERAL, 3};
    switch (syscallId) {
      case 78: {  // readlinkat
        const auto dirfd = registerFileSet.get(x0).get<int64_t>();
        const auto pathnameAddress = registerFileSet.get(x1).get<uint64_t>();
        const auto bufAddress = registerFileSet.get(x2).get<uint64_t>();
        const auto bufSize = registerFileSet.get(x3).get<uint64_t>();

        // Copy string at `pathnameAddress`
        char pathname[kernel::Linux::PATH_MAX];
        const char* ptr = memory + pathnameAddress;
        size_t i;
        for (i = 0; i < kernel::Linux::PATH_MAX; i++) {
          pathname[i] = ptr[i];
          if (ptr[i] == '\0') {
            break;
          }
        }

        if (i == kernel::Linux::PATH_MAX) {
          // TODO: Handle PATH_MAX case
          std::cout << "Path exceeds PATH_MAX" << std::endl;
          return {true, 0, {}};
        }

        char buffer[kernel::Linux::PATH_MAX];
        auto result = linux_.readlinkat(dirfd, pathname, buffer, bufSize);

        if (result < 0) {
          // TODO: Handle error case
          std::cout << "Error generated by readlinkat" << std::endl;
          return {true, 0, {}};
        }

        auto bytesCopied = static_cast<uint64_t>(result);

        stateChange = {{x0}, {result}};

        // Slice the returned path into <256-byte chunks for writing
        const char* bufPtr = buffer;
        for (i = 0; i < bytesCopied; i += 256) {
          auto size = std::min(bytesCopied - i, 256ul);
          stateChange.memoryAddresses.push_back({bufAddress + i, size});
          stateChange.memoryAddressValues.push_back(
              RegisterValue(bufPtr, size));
        }
        break;
      }
      case 94: {  // exit_group
        std::cout << "Received exit_group syscall: terminating" << std::endl;
        return {true, 0, {}};
      }
      case 160: {  // uname
        const uint64_t base = registerFileSet.get(x0).get<uint64_t>();
        const uint8_t len =
            65;  // Reserved length of each string field in Linux
        const char sysname[] = "Linux";
        const char nodename[] = "simeng.hpc.cs.bris.ac.uk";
        const char release[] = "0.0.0";
        const char version[] = "#1 SimEng Mon Apr 29 16:28:37 UTC 2019";
        const char machine[] = "aarch64";

        stateChange = {{x0},
                       {static_cast<uint64_t>(0)},
                       {{base, sizeof(sysname)},
                        {base + len, sizeof(nodename)},
                        {base + (len * 2), sizeof(release)},
                        {base + (len * 3), sizeof(version)},
                        {base + (len * 4), sizeof(machine)}},
                       {RegisterValue(sysname), RegisterValue(nodename),
                        RegisterValue(release), RegisterValue(version),
                        RegisterValue(machine)}};
        break;
      }
      case 174:  // getuid
        stateChange = {{x0}, {linux_.getuid()}};
        break;
      case 175:  // geteuid
        stateChange = {{x0}, {linux_.geteuid()}};
        break;
      case 176:  // getgid
        stateChange = {{x0}, {linux_.getgid()}};
        break;
      case 177:  // getegid
        stateChange = {{x0}, {linux_.getegid()}};
        break;
      case 214: {  // brk
        auto result = linux_.brk(registerFileSet.get(x0).get<uint64_t>());
        stateChange = {{x0}, {static_cast<uint64_t>(result)}};
        break;
      }
      default:
        std::cout << "Unrecognised syscall" << std::endl;
        return {true, 0, {}};
    }

    std::cout << "Resuming from 0x" << std::hex << nextInstructionAddress
              << std::dec << "\n"
              << std::endl;

    return {false, nextInstructionAddress, stateChange};
  }

  return {true, 0, {}};
}

std::vector<RegisterFileStructure> A64Architecture::getRegisterFileStructures()
    const {
  return {
      {8, 32},   // General purpose
      {16, 32},  // Vector
      {1, 1}     // NZCV
  };
}

ProcessStateChange A64Architecture::getInitialState(
    span<char> processMemory) const {
  ProcessStateChange changes;

  uint64_t stackPointer = linux_.getInitialStackPointer();
  // Set the stack pointer register
  changes.modifiedRegisters.push_back({A64RegisterType::GENERAL, 31});
  changes.modifiedRegisterValues.push_back(stackPointer);

  return changes;
}

bool A64Architecture::canRename(Register reg) const { return true; }

void A64Architecture::printException(const A64Instruction& insn) const {
  auto exception = insn.getException();
  std::cout << "Encountered ";
  switch (exception) {
    case A64InstructionException::EncodingUnallocated:
      std::cout << "illegal instruction";
      break;
    case A64InstructionException::ExecutionNotYetImplemented:
      std::cout << "execution not-yet-implemented";
      break;
    case A64InstructionException::SupervisorCall:
      std::cout << "supervisor call";
      break;
    case A64InstructionException::HypervisorCall:
      std::cout << "hypervisor call";
      break;
    case A64InstructionException::SecureMonitorCall:
      std::cout << "secure monitor call";
      break;
    default:
      std::cout << "unknown (id: " << static_cast<unsigned int>(exception)
                << ")";
  }
  std::cout << " exception\n";

  std::cout << "  Generated by instruction: \n"
            << "    0x" << std::hex << std::setfill('0') << std::setw(16)
            << insn.getInstructionAddress() << ": ";

  auto& metadata = insn.getMetadata();
  for (uint8_t byte : metadata.encoding) {
    std::cout << std::setfill('0') << std::setw(2)
              << static_cast<unsigned int>(byte) << " ";
  }
  std::cout << std::dec << "    ";
  if (exception == A64InstructionException::EncodingUnallocated) {
    std::cout << "<unknown>";
  } else {
    std::cout << metadata.mnemonic << " " << metadata.operandStr;
  }
  std::cout << "\n      opcode ID: " << metadata.opcode;
  std::cout << std::endl;
}

}  // namespace simeng
